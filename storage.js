const fs = require('fs');const Discord = require('discord.js');var jsonfile = require('jsonfile');var moment = require('moment');let DATABASE = jsonfile.readFileSync('./storage/database.json');let USERS = jsonfile.readFileSync('./storage/users.json');let MEALTYPES = [{n:'SOUP', v:10}, {n:'SALAD', v:10}, {n:'SANDWICH', v:12}, {n:'ALCHOHOLIC-DRINK', v:13}, {n:'DRINK', v:11}, {n:'SODA', v:11}, {n:'DESSERT', v:13}, {n:'CANNED-FOOD', v:8}];let INGREDIENTTYPES = ['CHEESE', 'BREAD', 'PASTE', 'SAUCE'];moment().format();const priceReducer = (acc, obj) => acc + (obj.sellPrice * obj.amount);const amountReducer = (acc, obj) => acc + parseInt(obj.amount);// access, formatting functionsfunction updateUsers() {  jsonfile.writeFileSync(`./storage/users.json`, USERS);}exports.userExists = function(userID) {  if(getUser(userID) == undefined) {    return false;  };  return true;}function bal(number) {  var split = (number+'').split('');  for(i=split.length-3;i>0;i-=3) {    if(i-3 > split.length) {      break;    }    split.splice(i, 0, ',');  }  return('`'+split.join('')+'`');}function getAllIndexes(arr, val) {    var indexes = [], i;    for(i = 0; i < arr.length; i++)        if (arr[i] === val)            indexes.push(i);    return indexes;}function getUser(ID) {  var index = (USERS.list.map(function(e) { return e.userID; }).indexOf(ID));  if(index != -1) {    return USERS.list[index];  }}function getItem(itemName) {  var index = DATABASE.items.map(function(e) { return e.name.toLowerCase(); }).indexOf(itemName.toLowerCase());  var pluralIndex = DATABASE.items.map(function(e) { return e.plural.toLowerCase(); }).indexOf(itemName.toLowerCase());  if(pluralIndex != -1) {    return DATABASE.items[pluralIndex];  } else if (index != -1) {    return DATABASE.items[index];  }}function confirm(message, vars, callback) {  message.channel.send("`f!confirm`")  let collector = new Discord.MessageCollector(message.channel, m => m.author.id === message.author.id, { max: 5, time: 10000 });  collector.on('collect', message => {    switch(message.content.toLowerCase()) {      case 'f!confirm':        callback(vars[0], vars[1], vars[2], vars[3], vars[4]);        break;      default:        message.channel.send('Cancelled.')    }    collector.stop();  });  updateUsers();}function errorMsg(channel, code) {  switch(code) {    case 'broke':      code = `You're broke! How did you lose all your money?!`      break;    case 'invEmpty':      code = `Your inventory is empty.`      break;    case 'shopInvalidIndex':      code = `Doesn't look like that's a valid shop item.`      break;    case 'experimentEmpty':      code = `You have no experiments running.`      break;    case 'experimentEarly':      code = `This experiment is still cooking.`      break;    case 'experimentDuplicates':      code = `You should only use each item once.`      break;    case 'recipesEmpty':      code = `You don't have any recipes in your recipe book.`      break;    case 'cropsEmpty':      code = `You don't have anything planted.`      break;    case 'cropsEarly':      code = `This crop isn't ready to harvest yet.`      break;    case 'plantNotSeed':      code = `You can't plant things that aren't seeds.`      break;    case 'userNotFound':      code = `Looks like this user doesn't have a farm.`      break;    default:      break;  }   channel.send(code);}function userOwns(author, itemName, amount, r=false, a=false, t=false, m=false) {  console.log(itemName)  var nameIndex = getAllIndexes(author.inventory.map(function(e) { return e.name.toLowerCase(); }), itemName.toLowerCase());  var pluralIndex = getAllIndexes(author.inventory.map(function(e) { return e.plural.toLowerCase(); }), itemName.toLowerCase());  var found = false;  var nonNeg = 0;  if(nameIndex.length != 0) {    nonNeg = nameIndex;  } else if(pluralIndex.length != 0){    nonNeg = pluralIndex  }  if(t) {    nonNeg = getAllIndexes(author.inventory.map(function(e) {       if(e.subtype != undefined) {        return e.subtype.toLowerCase();       }      return 'IGNORE';    }), itemName.toLowerCase());    if(nonNeg.length == 0) {      return false;    }  }  for(a=0;a<nonNeg.length;a++) {    if(author.inventory[nonNeg[a]].amount >= amount) {      if(r) {        console.log('removing ' + nonNeg[a] + ' ' + author.inventory[nonNeg[a]])        remove(author.inventory, nonNeg[a], amount);      }      if(a) {        author.inventory[nonNeg[a]].amount += amount;      };      if(m) {        return(author.inventory[nonNeg[a]]);      }      return true;    }  }  // if(nonNeg.length > 1) {  //   var total = nonNeg.reduce((acc, index) => acc + parseInt(author.inventory[index].amount), 0)  //   var mRet = [];  //   if(total >= amount) {  //     for(x=0;x<nonNeg.length;x++) {  //       if(r) {  //         remove(author.inventory, nonNeg[x], amount);  //       }  //       if(m) {  //         mRet.push(author.inventory[nonNeg[a]]);  //       }  //     }  //     if(m) {  //       return mRet;  //     }  //     return true;  //   }  // }  return false;}function remove(array, index, amount) {  if(amount == undefined || amount == 0) {    amount = array[index].amount;  }  if(array[index].amount == amount) {    array.splice(index, 1);  } else {    array[index].amount -= amount;  }  // remove this when you can be sure bot will be up for long periods of time  updateUsers();}function embed(fields, title, page, totalLength, imgUrl) {  const embed = {    "color": 7391638,    "thumbnail": {      "url": imgUrl    },    "author": {      "name": title,    },    "fields": fields,    "footer": {      "text": `(${page*4+1} -> ${page*4+5}) out of ${totalLength}`    }  };  return {embed};}//// checking functionsfunction hasDupes(arr) {  return arr.some(function(value, index) {    return arr.indexOf(value, index + 1) !== -1;  });}//// shop functionsfunction buy(message, item, amount) {  var author = getUser(message.author.id);  var price = item.buyPrice * amount;  if(author.balance < price) {    message.channel.send(`You don't have enough money. BAL: $${bal(author.balance)} PRICE: $${bal(price)}`);    return;  }  author.balance -= price;  item.amount = amount;  author.inventory.push(item);  message.channel.send(`Bought ${bal(amount)} ${item.name} for $${bal(item.buyPrice * amount)}.\nREMAINING BALANCE: $${bal(author.balance)}`)  updateUsers();}function sell(message, index, item, amount) {  var author = getUser(message.author.id);  author.balance += item.sellPrice * amount;  remove(author.inventory, index, amount);  message.channel.send(`Okay, I sold ${bal(amount)} ${item.plural} for $${bal(item.sellPrice * amount)}.`)  updateUsers();}function sellAll(message, author, count, total) {  author.inventory = [];  author.balance += total;  updateUsers();  message.channel.send(`Sold ${bal(count)} items for $${bal(total)}.`)}//// cooking functionsfunction generateMealRecipe(ingredients, time) {  var ingredientData = ingredients.map(str => getItem(str));  var timeBonus = Math.floor((Math.random() * time) + time/2)  var mealType = MEALTYPES[Math.floor(Math.random() * MEALTYPES.length)];  var newRecipe = {    startTime: moment(),    endTime: moment().add(time, 'minutes'),    ingredients: [],    specialIngredients: [],    item: {      type: 'MEAL',      subtype: mealType.n,      name:'',       description:'',       buyPrice: 0,      sellPrice: 0,      bonuses:{         harvest: {          duration: Math.floor(Math.random() * 1+ timeBonus/(Math.random() * ingredients.length)),          bonus:Math.floor(Math.random() * 20 + timeBonus/2)        },        exp: {          duration: Math.floor(Math.random() * 2+ timeBonus/(Math.random() * ingredients.length)),          bonus:Math.floor(Math.random() * 10 + timeBonus/2)        },        planting: {          duration:Math.floor(Math.random() * 5+ timeBonus/(Math.random() * ingredients.length)),          bonus: Math.floor(Math.random() * 15 + timeBonus/2)        }      },    }  }  var specialIngredientsLength = Math.floor(Math.random() * 2)+1;  var alreadyAdded = [];  for(i=0;i<ingredientData.length;i++) {    newRecipe.item.sellPrice += ingredientData[i].buyPrice + (ingredientData[i].buyPrice * (0.1 + specialIngredientsLength));    newRecipe.ingredients.push({name: ingredientData[i].name, value: Math.floor(Math.random() * 5+(timeBonus*3)) + 1});  }  newRecipe.item.sellPrice = newRecipe.item.sellPrice * mealType.v;  newRecipe.item.buyPrice = (newRecipe.item.sellPrice * 1.3 );  for(i=0;i<specialIngredientsLength;i++) {    var type = INGREDIENTTYPES[Math.floor(Math.random() * INGREDIENTTYPES.length)];    if(!alreadyAdded.includes(type)) {      alreadyAdded += type;      newRecipe.specialIngredients.push({name: type, value:Math.floor(Math.random()*3)+1});    }  }  console.log(newRecipe);  return newRecipe;}function generateIngredientRecipe(ingredients, time) {  var ingredientData = ingredients.map(str => getItem(str));  var timeBonus = Math.floor((Math.random() * time) + time/2)  var newIngredientRecipe = {    startTime: moment(),    endTime: moment().add(time, 'minutes'),    ingredients: [],    item: {      type: 'INGREDIENT',      subtype: INGREDIENTTYPES[Math.floor(Math.random() * INGREDIENTTYPES.length)],      name:'',       description:'',       buyPrice: 0,      sellPrice: 0,      quality: 0,    }  }  for(i=0;i<ingredientData.length;i++) {    newIngredientRecipe.item.sellPrice += ingredientData[i].buyPrice + (ingredientData[i].buyPrice * 0.3);    newIngredientRecipe.ingredients.push({name: ingredientData[i].name, value: Math.floor(Math.random() * 5+(timeBonus*3)) + 1});  }  newIngredientRecipe.item.quality = (time * ingredients.length) * (Math.floor(Math.random() * 25) + 5);  newIngredientRecipe.item.buyPrice = newIngredientRecipe.item.sellPrice * 1.3;  console.log(newIngredientRecipe);  return newIngredientRecipe;}function cook(message, recipe, amount) {  var author = getUser(message.author.id);  var quality = 1;  for(i=0;i<recipe.ingredients.length;i++) {    var ingredientInfo = recipe.ingredients[i];    userOwns(author, ingredientInfo.name, ingredientInfo.value*amount, true);  }  if(recipe.item.type == 'MEAL') {    for(i=0;i<recipe.specialIngredients.length;i++) {      var ingredientInfo = recipe.specialIngredients[i];      console.log(ingredientInfo);      quality += userOwns(author, ingredientInfo.name, ingredientInfo.value*amount, false, false, true, true).quality * 1.2;      userOwns(author, ingredientInfo.name, ingredientInfo.value*amount, true, false, true);    }  }  var item = recipe.item;  item.amount = amount;  item.quality = quality;  author.inventory.push(item);  message.channel.send(`Tasty! You cooked ${amount} "${item.name}!"`)  updateUsers();}//// misc commandsexports.gift = function(message, otherID, index, amount) {  var author = getUser(message.author.id);  var recipient = getUser(otherID.replace(/[&\/\\#,+()@$~%.'":*?<>!{}]/g, ''));  if(author.inventory.length == 0) {    errorMsg(message.channel, 'invEmpty');    return;  } else if(author.inventory[index-1] == undefined) {    message.channel.send(`#${index} is not a valid place in your inventory.`);    return;  }  index = index-1  if(recipient == undefined) {    errorMsg(message.channel, 'userNotFound');    return;  }  var item = author.inventory[index];  if(amount > item.amount) {    message.channel.send(`You can't give away more ${item.plural} than you have.`);    return;  }  message.channel.send(`Are you sure you want to give ${amount} ${item.plural} to ${recipient.name}?`)  confirm(message, [message, author, recipient, item, index, amount], gift);}function gift(message, author, recipient, item, index, amount) {  var giftItem = author.inventory[index]  giftItem.amount = amount;  recipient.inventory.push(giftItem);  if(amount == item.amount) {    author.inventory.splice(index, 1)  } else {    author.inventory[index].amount -= amount;  }  updateUsers();  message.channel.send(`Your gift was sent!`);}exports.consolidate = function(message, indexes) {  var author = getUser(message.author.id);  if(indexes == undefined) {    return;  }  indexes = indexes.map(function(index) {     if(index-1 >= 0 && index-1 <= author.inventory.length) {      return parseInt(index-1);    }  });  if(indexes.length == 0) {    return;  }  var items = indexes.map(function(index) {return author.inventory[index]});  if(!items.every( (val, i, arr) => val.name === arr[0].name)) {    return;  }  var newBag = JSON.parse(JSON.stringify(author.inventory[indexes[0]]))  newBag.amount = items.reduce(amountReducer, 0);  console.log(indexes);  for(i=indexes.length-1;i>=0;i--) {    author.inventory.splice(indexes[i], 1);  }  author.inventory.push(newBag);  updateUsers();}//// display functionsfunction star(q) {  var ret = '☆☆☆'  if(q >= 100) {    return '★★★'  }  if(q >= 50) {    return '★★☆'  }  if(q >= 10) {    return '★☆☆'  }  return '☆☆☆'}function displayShop(obj, place) {  var msg = {name:`   #${place}: ${obj.plural.toUpperCase()} -- ${obj.type}\n$${bal(obj.buyPrice)}`, value:`*${obj.description}*\n`};  if(obj.type == 'SEED') {    msg.value += (` *Grows in about ${bal(obj.growTime)} minutes.*\n`)  }  return msg;}function displayInv(obj, place) {  if(obj.type == 'MEAL') {    return(displayMeal(obj, place));  };  if(obj.type == 'INGREDIENT') {    return(displaySpecialIngredient(obj, place))  };  return({name:`   #${place}: A Bag of ${bal(obj.amount)} ${obj.plural}.`, value: `Worth $${bal(obj.sellPrice * obj.amount)}.`});}function displayMeal(obj, place) {  return({name:`   #${place}: ${bal(obj.amount)} *${obj.name}.*`, value: `Quality: ${(obj.quality)}\nWorth $${bal(obj.sellPrice * obj.amount)}.`});}function displaySpecialIngredient(obj, place) {  return({name:`   #${place}: ${bal(obj.amount)} *${obj.name}.*`, value: `${obj.type} - ${obj.subtype}\nQuality: ${(obj.quality)}\nWorth $${bal(obj.sellPrice * obj.amount)}.`});}function displayExperiment(obj, place) {  return({name:`#${place}: A Cauldron of ${obj.ingredients.length} unique ingredients is brewing.`, value: `Ready ${moment().to(obj.endTime)}.\n\n${obj.ingredients.map(obj=>`?? ${getItem(obj.name).plural}`).join('\n')}\n`});}function displayCrop(obj, place) {  return({name:`#${place}: *${bal(obj.amount)} ${obj.plural}!*`, value: `Harvestable ${moment().to(obj.endTime)}.`});}function displayRecipe(obj, place) {  var msg = ({name:`#${place}: *${obj.item.name}*`, value: `${obj.item.type} - ${obj.item.subtype}\n"${obj.item.description}"\n\n${obj.ingredients.map(obj=>displayIngredient(obj)).join('\n')}`});  if(obj.item.type == 'MEAL') {    msg.value += (`\n*––SPECIAL REQUIREMENTS––*\n${obj.specialIngredients.map(obj=>(`${obj.value} of any ${obj.name}`)).join('\n')}\n`)  }  return msg;}function displayIngredient(obj) {  return(`${obj.value} ${getItem(obj.name).plural}`)}//// command to function processingexports.start = function (data, channel) {  USERS.list.push(data);  updateUsers()}  // shop, inventory, moneyexports.inventoryList = function(message, passPage) {  var author = getUser(message.author.id);  if(author.inventory.length == 0) {    errorMsg(message.channel, 'invEmpty')    return;  }  var page = 0;  if(passPage == undefined || passPage == null || passPage == 0) {  } else {    page = passPage-1  }  var i=0;  var fields = (author.inventory.map(function(item) {    i++;    return displayInv(item, i);  }));  var totalLength = fields.length;  fields = fields.slice(page*4, page*4+5)  message.channel.send(embed(fields, `${author.name}'s inventory:`, page, totalLength, ''));}exports.toss = function(message, arrayName, index) {  var author = getUser(message.author.id);  var arr;  switch(arrayName.toLowerCase()) {    case 'inventory':      arr = author.inventory;      break;    case 'crops':      arr = author.farm.crops;      break;    case 'recipes':      arr = author.restaurant.recipes;      break;    case 'experiments':      arr = author.restaurant.experiments;      break;  }  var item = arr[index-1];  if(arr.length == 0) {    errorMsg(message.channel, 'arrEmpty')    return;  }  if(item == undefined) {    message.channel.send(`#${index} is not a valid place in your inventory.`);    return;  }    console.log(item);  message.channel.send(`Are you sure you want to toss #${index} in ${arrayName}?`)  confirm(message, [arr, index-1], remove);}exports.balance = function(message) {  var author = getUser(message.author.id);  message.channel.send(`You have $${bal(author.balance)} in your account.\nYou are level ${bal(author.level)}. (${bal(author.exp)}/${bal(author.level*2)}) EXP`);}exports.giveMoney = function(message, amount) {  var author = getUser(message.author.id);  author.balance += parseInt(amount);  updateUsers();}exports.shopList = function(message, passPage) {  var page = 0;  if(passPage == undefined || passPage == null || passPage == 0) {  } else {    page = passPage-1  }  var i=0;  var fields = (DATABASE.stock.map(function(index) {    i++;    return displayShop(DATABASE.items[index], i);  }));  var totalLength = fields.length;  fields = fields.slice(page*4, page*4+5)  message.channel.send(embed(fields, `DISCOUNT FARM GOODS`, page, totalLength, "https://image.flaticon.com/icons/svg/189/189093.svg"));}exports.shopBuy = function(message, index, amount) {  var author = getUser(message.author.id);  var item = DATABASE.items[DATABASE.stock[index-1]];  if(item == undefined) {    errorMsg(message.channel, 'shopInvalidIndex')    return;  }  if(amount == undefined) {    amount = Math.floor(author.balance/item.buyPrice);    if(amount == 0) {      errorMsg(channel, `broke`);    }    message.channel.send(`Are you sure you want to buy ${bal(amount)} ${item.plural} for $${bal(item.buyPrice * amount)}?`)    confirm(message, [message, item, amount], buy);  } else {    buy(message, item, amount);  }}exports.shopSell = function(message, index, amount) {  var author = getUser(message.author.id);  var item = author.inventory[index-1];  if(author.inventory.length == 0) {    errorMsg(message.channel, 'invEmpty')    return;  }  if(item == undefined) {    message.channel.send(`#${index} is not a valid place in your inventory.`);    return;  }  if(amount == undefined) {    amount = item.amount;  }    if(amount > item.amount) {    message.channel.send(`You can't sell more ${item.plural} than you have!`);    return;  };  message.channel.send(`Are you sure you want to sell ${bal(amount)} of your ${bal(item.amount)} ${item.plural} for $${bal(item.sellPrice * amount)}?`)  confirm(message, [message, index-1, item, amount], sell);}exports.shopSellAll = function(message) {  var author = getUser(message.author.id);  if(author.inventory.length == 0) {    errorMsg(message.channel, 'invEmpty')    return;  }  var total = author.inventory.reduce(priceReducer, 0);  var count = author.inventory.reduce(amountReducer, 0);  message.channel.send(`Are you sure you want to sell absolutely everything in your inventory for $${bal(total)}?`)  confirm(message, [message, author, count, total], sellAll);}  //  // farmingexports.cropList = function(message, passPage) {  var author = getUser(message.author.id);  if(author.farm.crops.length == 0) {    errorMsg(message.channel, 'cropsEmpty')    return;  }  var page = 0;  if(passPage == undefined || passPage == null || passPage == 0) {  } else {    page = passPage-1  }  var i=0;  var fields = (author.farm.crops.map(function(item) {    i++;    return displayCrop(item, i);  }));  var totalLength = fields.length;  fields = fields.slice(page*4, page*4+5)  message.channel.send(embed(fields, `Crops on ${author.farm.name}`, page, totalLength, ""));}exports.harvest = function(message, index, amount) {  var author = getUser(message.author.id);  var item = author.farm.crops[index-1];  if(item == undefined) {    return;  }  if(amount == undefined) {    amount = item.amount;  };  if(!moment().isAfter(item.endTime)) {    errorMsg(message.channel, 'cropsEarly')    return;  }  if(amount > item.amount) {    message.channel.send(`You can't harvest more ${item.plural} than you have!`);    return;  };  if(item.amount == amount) {    author.farm.crops.splice(index-1, 1);  } else {    item.amount -= amount;  }  var got = [];  for(y=0;y<item.yields.length;y++) {    var harvItem = getItem(item.yields[y].name);    harvItem.amount = 0;    for(i=0;i<amount;i++) {      var addition = (Math.floor(Math.random() * (item.yields[y].max+(author.level / 100) - item.yields[y].min-(author.level / 100))) + item.yields[y].min);      harvItem.amount += addition;      author.exp += addition;      if(author.exp > author.level*2) {        author.exp = 0;         author.level++;      }    }    if(harvItem.amount != 0) {      author.inventory.push(harvItem);      got.push(`${bal(harvItem.amount)} ${harvItem.plural}`);    }  }    message.channel.send(`Wow! You got ${got.join(' and ')}!`)  updateUsers();}exports.plant = function(message, index, amount) {  var author = getUser(message.author.id);  var item = author.inventory[index-1];  if(item == undefined) {    message.channel.send(`#${index} is not a valid place in your inventory.`);    return;  }  var crop =  JSON.parse(JSON.stringify(item))  if(amount == undefined) {    amount = item.amount;  }  if(author.inventory.length == 0) {    errorMsg(message.channel, 'invEmpty')    return;  }  if(item.type != 'SEED') {    errorMsg(message.channel, 'plantNotSeed')    return;  }  if(amount > item.amount) {    message.channel.send(`You can't plant more ${item.plural} than you have.`);    return;  };  if(item.amount == amount) {    author.inventory.splice(index-1, 1);  } else {    item.amount -= amount;  }  crop.startTime = moment();  crop.endTime = moment().add(item.growTime, 'm')  crop.amount = amount;  author.farm.crops.push(crop);  message.channel.send(`Planted ${bal(amount)} ${item.plural}.`)  updateUsers();}  //  // cookingexports.experiment = function(message, ingredients, time) {  var author = getUser(message.author.id);  if(hasDupes(ingredients)) {    errorMsg(message.channel, 'experimentDuplicates')    return;  };  for(i=0;i<ingredients.length;i++) {    var data = getItem(ingredients[i]);    if(data == undefined) {      return;    }    if(!userOwns(author, ingredients[i], 1)) {      message.channel.send(`You don't have any ${data.plural}!`)      return;    }  };  if(isNaN(parseInt(time))) {    return;  }  for(i=0;i<ingredients.length;i++) {    userOwns(author, ingredients[i], 1, true);  }  var rand = Math.floor(Math.random() * 2);  switch(rand) {    case 1:      author.restaurant.experiments.push(generateIngredientRecipe(ingredients, time));      break;    default:      author.restaurant.experiments.push(generateMealRecipe(ingredients, time));      break;  }  updateUsers();  message.channel.send(`It's in the oven! Cooking ${ingredients.length} ingredients for ${time} minutes.`)}exports.experimentList = function(message, passPage) { var author = getUser(message.author.id);  if(author.restaurant.experiments.length == 0) {    errorMsg(message.channel, 'experimentEmpty')    return;  }  var page = 0;  if(passPage == undefined || passPage == null || passPage == 0) {  } else {    page = passPage-1  }  var i=0;  var fields = (author.restaurant.experiments.map(function(item) {    i++;    return displayExperiment(item, i);  }));  var totalLength = fields.length;  fields = fields.slice(page*4, page*4+5)  message.channel.send(embed(fields, `Experiments:`, page, totalLength, ""));}exports.finalize = function(message, index) {  var author = getUser(message.author.id);  var experiment = author.restaurant.experiments[index-1];  if(experiment == undefined) {    return;  }  if(!moment().isAfter(experiment.endTime)) {    errorMsg(message.channel, 'experimentEarly')    return;  }  console.log(experiment);  var addon = '';  if(experiment.item.type == 'MEAL') {    addon = `It also needs ${experiment.specialIngredients.map(obj=>(`${obj.value} of any ${obj.name}`)).join(' and ')}.`  }  message.channel.send(`Yummy! You cooked something ${experiment.item.subtype.toLowerCase()}-like with ${experiment.ingredients.map(obj=>displayIngredient(obj)).join(' and ')}. ${addon} What's the name of your new ${experiment.item.type.toLowerCase()}?`);  var tree = 0;  let collector = new Discord.MessageCollector(message.channel, m => m.author.id === message.author.id);  console.log(experiment);  collector.on('collect', message => {    switch(tree) {      case 0:        experiment.item.name = message.content;        experiment.item.plural = message.content;        message.channel.send('How would you describe it?')        tree++;        break;      case 1:        console.log(experiment);        var a = 'an'        if(experiment.item.type == 'MEAL') {          a = 'a';        }        message.channel.send(`Wow! You learned how to make ${a} ${experiment.item.type.toLowerCase()}: ${experiment.item.name}! This would go for about $${bal(experiment.item.sellPrice)}.`);        experiment.item.description = message.content;        author.restaurant.recipes.push(experiment);        author.restaurant.experiments.splice(index-1, 1);        updateUsers();        collector.stop();        break;      default:        message.channel.send('Something went wrong...');        break;    }  });}exports.recipesList = function(message, passPage) {  var author = getUser(message.author.id);  if(author.restaurant.recipes.length == 0) {    errorMsg(message.channel, 'recipesEmpty')    return;  }  var page = 0;  if(passPage == undefined || passPage == null || passPage == 0) {  } else {    page = passPage-1  }  var i=0;  var fields = (author.restaurant.recipes.map(function(item) {    i++;    return displayRecipe(item, i);  }));  var totalLength = fields.length;  fields = fields.slice(page*4, page*4+5)  message.channel.send(embed(fields, `'${author.restaurant.name}' Recipe Book:`, page, totalLength, ""));}exports.cook = function(message, index, amount) {  var author = getUser(message.author.id);  var recipe = author.restaurant.recipes[index-1];  if(author.restaurant.recipes.length == 0) {    errorMsg(message.channel, 'recipesEmpty');    return;  }  if(author.inventory.length == 0) {    errorMsg(message.channel, 'invEmpty');    return;  }  if(recipe == undefined) {    message.channel.send(`#${index} is not a valid place in your recipe book.`);    return;  };  if(amount == 0 || amount == undefined) {    amount = 1;  }  for(i=0;i<recipe.ingredients.length;i++) {    var data = getItem(recipe.ingredients[i].name);    if(data == undefined) {      return;    };    if(!userOwns(author, recipe.ingredients[i].name, recipe.ingredients[i].value*amount)) {      var need = recipe.ingredients[i].value*amount;      message.channel.send(`You don't have a bag of enough ${data.plural} to cook ${bal(amount)} ${recipe.item.name}. This recipe requires ${bal(need)} ${data.plural}.`)      return;    }  };  if(recipe.item.type == 'MEAL') {    for(i=0;i<recipe.specialIngredients.length;i++) {      var data = recipe.specialIngredients[i];      console.log(data);      console.log(data.name);      if(!userOwns(author, data.name, data.value*amount, false, false, true)) {        var need = recipe.specialIngredients[i].value*amount;        message.channel.send(`You don't have a bag of enough ${data.name} ingredients to cook ${bal(amount)} ${recipe.item.name}. This recipe requires ${bal(need)} ${data.name} ingredients.`)        return;      }    };  }  if(amount == undefined) {    amount = 1;  };  message.channel.send(`Are you sure you want to cook ${bal(amount)} ${recipe.item.name}?`);  confirm(message, [message, recipe, amount], cook);}  ////